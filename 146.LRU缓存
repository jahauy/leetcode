/* 
 * @author: Edison
 * @date: 2022/6/30
*/
// #include "public.h"

using namespace std;

using DataT = pair<int, int>;

struct Node {
    DataT data;
    Node* pre;
    Node* next;

    Node() : data(-1, -1), pre(nullptr), next(nullptr)
    {}

    Node(int key, int val) : data(key, val), pre(nullptr), next(nullptr)
    {}
};

void LinkedListInsert(Node* target, Node* p)
{
    p->next = target->next;
    p->pre = target;
    target->next->pre = p;
    target->next = p;
}

void LinkedListRemove(Node* p, bool del= true)
{
    p->next->pre = p->pre;
    p->pre->next = p->next;
    if (del) delete p;
}

class LRUCache {
public:
    LRUCache(int capacity) : capacity(capacity), begin(new Node()), end(new Node())
    {
        begin->next = end;
        end->pre = begin;
    }

    int get(int key)
    {
        if (table.count(key) == 0) return -1;
        auto tmp = table[key];
        LinkedListRemove(tmp, false);
        LinkedListInsert(begin, tmp);
        return tmp->data.second;
    }

    void put(int key, int value)
    {
        if (table.count(key) != 0) {
            auto p = table[key];
            LinkedListRemove(p, false);
            p->data.second = value;
            LinkedListInsert(begin, p);
        } else {
            if (table.size() == capacity) {
                auto tmp = end->pre;
                table.erase(tmp->data.first);
                LinkedListRemove(tmp);
            }
            auto cur = new Node(key, value);
            table.insert(make_pair(key, cur));
            LinkedListInsert(begin, cur);
        }
    }

private:
    unordered_map<int, Node*> table;
    const int capacity;
    Node* begin; // 头
    Node* end; // 尾
};
